"""ALB provider â€” shared lookup or dedicated provisioning."""

from __future__ import annotations

from typing import Any

import boto3
from aws_cdk import Stack, aws_ec2, aws_elasticloadbalancingv2 as elbv2
from constructs import Construct


class AlbProvider(Construct):
    """Provides an ALB target attachment point.

    In **shared** mode the construct looks up an existing ALB by name.
    In **dedicated** mode it provisions
    a new internet-facing ALB with an HTTPS listener.
    """

    def __init__(
        self,
        scope: Construct,
        construct_id: str,
        *,
        vpc: aws_ec2.IVpc,
        project_name: str,
        env_name: str,
        alb_mode: str = "shared",
        shared_alb_name: str = "",
        certificate_arn: str | None = None,
    ) -> None:
        super().__init__(scope, construct_id)

        self.vpc = vpc
        self.project_name = project_name
        self.env_name = env_name
        self._locally_allocated_priorities: list[int] = []

        stack = Stack.of(self)

        if alb_mode == "shared":
            alb_name = shared_alb_name
            details = self._get_alb_details(stack, alb_name)

            self.alb_arn = details["alb_arn"]
            self.listener_arn = details["listener_arn"]
            self.alb_security_group = aws_ec2.SecurityGroup.from_security_group_id(
                self, "AlbSg", details["security_group_id"]
            )

            self.listener = elbv2.ApplicationListener.from_application_listener_attributes(
                self,
                "Listener",
                listener_arn=self.listener_arn,
                security_group=self.alb_security_group,
            )
            self._is_shared = True
        else:
            # Dedicated ALB
            self.alb = elbv2.ApplicationLoadBalancer(
                self,
                "Alb",
                vpc=vpc,
                internet_facing=True,
                load_balancer_name=f"{project_name}-{env_name}-alb",
            )
            self.alb_security_group = self.alb.connections.security_groups[0]

            if certificate_arn:
                cert = elbv2.ListenerCertificate.from_arn(certificate_arn)
                self.listener = self.alb.add_listener(
                    "HttpsListener",
                    port=443,
                    certificates=[cert],
                    default_action=elbv2.ListenerAction.fixed_response(
                        status_code=404,
                        content_type="text/plain",
                        message_body="Not Found",
                    ),
                )
            else:
                self.listener = self.alb.add_listener(
                    "HttpListener",
                    port=80,
                    default_action=elbv2.ListenerAction.fixed_response(
                        status_code=404,
                        content_type="text/plain",
                        message_body="Not Found",
                    ),
                )
            self.listener_arn = self.listener.listener_arn
            self._is_shared = False

    def add_target(
        self,
        construct_id: str,
        *,
        targets: list[elbv2.IApplicationLoadBalancerTarget],
        port: int,
        health_check_path: str,
        host_header: str,
    ) -> elbv2.ApplicationTargetGroup:
        """Register targets with a host-header rule on the listener."""
        tg = elbv2.ApplicationTargetGroup(
            self,
            f"Tg-{construct_id}",
            vpc=self.vpc,
            port=port,
            protocol=elbv2.ApplicationProtocol.HTTP,
            target_type=elbv2.TargetType.IP,
            targets=targets,
            health_check=elbv2.HealthCheck(
                path=health_check_path,
                healthy_http_codes="200-399",
            ),
        )

        priority = self._next_priority()

        elbv2.ApplicationListenerRule(
            self,
            f"Rule-{construct_id}",
            listener=self.listener,
            priority=priority,
            conditions=[elbv2.ListenerCondition.host_headers([host_header])],
            target_groups=[tg],
        )

        return tg

    # ------------------------------------------------------------------
    # Priority management
    # ------------------------------------------------------------------

    def _next_priority(self) -> int:
        """Find the next available listener rule priority."""
        stack = Stack.of(self)

        if self._is_shared:
            existing = self._get_existing_priorities(stack, self.listener_arn)
        else:
            existing = []

        all_used = set(existing) | set(self._locally_allocated_priorities)
        priority = 1
        while priority in all_used:
            priority += 1
        self._locally_allocated_priorities.append(priority)
        return priority

    def _get_existing_priorities(self, stack: Stack, listener_arn: str) -> list[int]:
        try:
            client = boto3.client("elbv2", region_name=stack.region)
            paginator = client.get_paginator("describe_rules")
            priorities: list[int] = []
            for page in paginator.paginate(ListenerArn=listener_arn):
                for rule in page["Rules"]:
                    if rule["Priority"] != "default":
                        priorities.append(int(rule["Priority"]))
            return priorities
        except Exception:
            return []

    def _get_alb_details(self, stack: Stack, alb_name: str) -> dict[str, Any]:
        client = boto3.client("elbv2", region_name=stack.region)
        response = client.describe_load_balancers(Names=[alb_name])
        if not response["LoadBalancers"]:
            raise ValueError(f"ALB '{alb_name}' not found")
        alb = response["LoadBalancers"][0]

        listeners_resp = client.describe_listeners(
            LoadBalancerArn=alb["LoadBalancerArn"]
        )
        https_listener = next(
            (
                l
                for l in listeners_resp["Listeners"]
                if l["Protocol"] == "HTTPS" and l["Port"] == 443
            ),
            None,
        )
        if not https_listener:
            raise ValueError(f"No HTTPS:443 listener on ALB '{alb_name}'")

        return {
            "alb_arn": alb["LoadBalancerArn"],
            "security_group_id": alb["SecurityGroups"][0],
            "listener_arn": https_listener["ListenerArn"],
        }
